#!/usr/local/bin/python3
import asyncio
import grpc
import rpc_pb2
import rpc_pb2_grpc
from aiohttp import web
import logging
import sys
import time
from common import retry, get_eth0_ipv4

log = {}
out_of_order_requests = {}
count = 0

# potentially secondary could run rpc server and web server separately, but would need to share data somehow one with another.

async def delay(secs):
    logging.info('Async sleeping for %s sec...', secs)
    await asyncio.sleep(secs)

# def delay(secs):
#     logging.info('Sleeping for %s sec...', secs)
#     time.sleep(secs)

def process_unordered_requests(tr_id):
    tmp = tr_id+1
    while tmp in out_of_order_requests:
        logging.info(f'Adding previously unordered msg to log {(tmp, out_of_order_requests[tmp])}')
        # also removes tmp from dict
        log[tmp] = out_of_order_requests.pop(tmp)

# GRPC server
class Replicator(rpc_pb2_grpc.ReplicatorServicer):
    async def replicateMsg(
            self, request: rpc_pb2.Request,
            context: grpc.aio.ServicerContext) -> rpc_pb2.Response:
        logging.info('Processing replicateMsg gRPC request')

        global count
        # TODO break this into functions by simulation
        # for simulating temporary inconsistency
        if (len(sys.argv) == 5 and sys.argv[1] == 'delay' and request.msg == sys.argv[3] and count < int(sys.argv[4])):           
            count += 1
            await delay(int(sys.argv[2]))
        
        # skip this when simulating out-of-order or duplication
        need_to_skip_this_for_simulation = len(sys.argv) == 4 \
            and (sys.argv[1] == 'dont_add_and_abort' or sys.argv[1] == 'add_and_abort')\
            and request.msg == sys.argv[2]\
            and count < int(sys.argv[3])
        if not need_to_skip_this_for_simulation:
            if (request.tr_id in log):
                logging.error(f'Duplication detected: value with tr_id {request.tr_id} already present')
                return rpc_pb2.Response(success=True)
            if (request.tr_id != 1 and request.tr_id-1 not in log):
                logging.info(f'Got an out of order request {(request.tr_id, request.msg)}')
                out_of_order_requests[request.tr_id] = request.msg
                return rpc_pb2.Response(success=True)

        # for simulating out-of-order
        if (len(sys.argv) == 4 and sys.argv[1] == 'dont_add_and_abort' and request.msg == sys.argv[2] and count < int(sys.argv[3])):
            count += 1
            raise Exception('MyException')
        else:
            log[request.tr_id] = request.msg

        process_unordered_requests(request.tr_id)

        # for simulating duplication
        if (len(sys.argv) == 4 and sys.argv[1] == 'add_and_abort' and request.msg == sys.argv[2] and count < int(sys.argv[3])):
            count += 1
            raise Exception('MyException')

        logging.info('%s was appended to replica-log\n', (request.tr_id, request.msg))
        return rpc_pb2.Response(success=True)

async def rpc_serve():
    server = grpc.aio.server()
    rpc_pb2_grpc.add_ReplicatorServicer_to_server(Replicator(), server)
    listen_addr = f'{get_eth0_ipv4()}:50051'
    server.add_insecure_port(listen_addr)
    logging.info('Starting server on %s', listen_addr)
    await server.start()
    await server.wait_for_termination()

#GRPC client
CHANNEL_OPTIONS = [
    ('grpc.enable_retries', 0),
]

async def rejoin():
    async with grpc.aio.insecure_channel(target=f'dist_systems.m:{50051}',
                                         options=CHANNEL_OPTIONS) as channel:
        stub = rpc_pb2_grpc.ReplicatorStub(channel)
        logging.info(f'Waiting for gRPC response from master')
        response = await stub.rejoin(rpc_pb2.RejoinRequest())
        logging.info(f'Rejoining with master: {len(response.requests)} items received')
        for item in response.requests:
            logging.info(f'Adding {(item.tr_id, item.msg)} after rejoining')
            log[item.tr_id] = item.msg


# HTTP server
async def handle_list(request):
    return web.Response(text='\n'.join([log[k] for k in sorted(log.keys())]) + '\n')

# Main
async def main():
    app = web.Application()
    app.add_routes([web.get('/list', handle_list)])
    logging.basicConfig(
        level=logging.DEBUG,
        format='[%(asctime)s.%(msecs)03d] %(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s',
        datefmt='%H:%M:%S',
        stream=sys.stdout)
    await asyncio.gather(rpc_serve(), web._run_app(app, access_log=None), retry(rejoin))

asyncio.run(main())